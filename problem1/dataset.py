"""
Dataset loader for font generation task.
Supports two metadata formats:
1) fonts_metadata.json  (teacher's format)
   {
     "train": [{"path": "fonts/train/A_bold_0000.png", "letter": "A", "font": 1}, ...],
     "val":   [...]
   }

2) fonts/metadata.json  (generated by setup_data.py you provided)
   {
     "letters": ["A",...,"Z"],
     "font_styles": [...],
     "image_size": 28,
     "train_samples": [{"filename": "...", "letter": "A", "letter_idx": 0, ...}, ...],
     "val_samples":   [...]
   }
"""

from __future__ import annotations
import os
import json
from pathlib import Path
from typing import Literal, Tuple

import numpy as np
import torch
from torch import Tensor
from torch.utils.data import Dataset
from PIL import Image


class FontDataset(Dataset):
    def __init__(
        self,
        data_dir: str | os.PathLike,
        split: Literal["train", "val"] = "train",
        normalize: Literal["zero_one", "neg_one_one"] = "zero_one",
        enforce_size: int = 28,
    ):
        """
        Args:
            data_dir: 根目錄（指到包含 fonts/ 的資料夾，例如 hw2-starter/data）
            split: 'train' or 'val'
            normalize:
                - 'zero_one'   -> 輸出值域 [0,1]（符合老師檔頭註解）
                - 'neg_one_one'-> 輸出值域 [-1,1]（GAN 常用，tanh 友善）
            enforce_size: 影像長寬目標（預設 28）
        """
        self.data_dir = Path(data_dir)
        self.split = split
        self.normalize = normalize
        self.enforce_size = enforce_size

        assert self.split in ("train", "val"), f"split must be 'train' or 'val', got {self.split}"
        assert self.data_dir.exists(), f"data_dir not found: {self.data_dir}"

        # 嘗試載入兩種 metadata 之一定義
        meta_teacher = self.data_dir / "fonts_metadata.json"
        meta_generated = self.data_dir / "metadata.json"

        if meta_teacher.exists():
            self._load_teacher_metadata(meta_teacher)
        elif meta_generated.exists():
            self._load_generated_metadata(meta_generated)
        else:
            raise FileNotFoundError(
                f"Cannot find metadata. Tried:\n  - {meta_teacher}\n  - {meta_generated}"
            )

        # 字母映射 A..Z -> 0..25
        self.letter_to_id = {chr(65 + i): i for i in range(26)}

        # 基本檢查
        assert len(self.samples) > 0, f"No samples for split={self.split}"
        # 檢查第一張存在
        first_path = self._resolve_path(self.samples[0])
        assert first_path.exists(), f"Sample file not found: {first_path}"

    # -------- metadata loaders --------
    def _load_teacher_metadata(self, meta_path: Path) -> None:
        """
        老師版本 fonts_metadata.json
        期望每筆有 {"path": "...", "letter": "A", "font": int}
        """
        with open(meta_path, "r", encoding="utf-8") as f:
            metadata = json.load(f)

        if self.split not in metadata:
            raise KeyError(f"Key '{self.split}' missing in {meta_path}")
        self.samples = metadata[self.split]
        self.format = "teacher"  # 標記目前使用的格式

    def _load_generated_metadata(self, meta_path: Path) -> None:
        """
        你提供的 setup_data.py 產生之 fonts/metadata.json
        使用 train_samples / val_samples 與 filename 欄位
        """
        with open(meta_path, "r", encoding="utf-8") as f:
            metadata = json.load(f)

        key = f"{self.split}_samples"
        if key not in metadata:
            raise KeyError(f"Key '{key}' missing in {meta_path}")
        self.samples = metadata[key]
        self.format = "generated"  # 標記目前使用的格式

    # -------- path resolver --------
    def _resolve_path(self, sample: dict) -> Path:
        """
        依照不同 metadata 版型，解析影像相對路徑。
        """
        if self.format == "teacher":
            # 老師的 path 通常已含 'fonts/train/xxx.png' 或 'fonts/val/xxx.png'
            return self.data_dir / sample["path"]
        else:
            # 你的版本只有 filename，需要自己組路徑
            return self.data_dir / self.split / sample["filename"]

    # -------- dataset API --------
    def __len__(self) -> int:
        return len(self.samples)

    def __getitem__(self, idx: int) -> Tuple[Tensor, int]:
        sample = self.samples[idx]
        img_path = self._resolve_path(sample)

        # 讀圖：強制灰階
        with Image.open(img_path) as im:
            im = im.convert("L")
            # 保證 28×28（或 enforce_size）
            if im.size != (self.enforce_size, self.enforce_size):
                im = im.resize((self.enforce_size, self.enforce_size), Image.LANCZOS)

            img = np.asarray(im, dtype=np.float32)  # 0..255

        # 正規化
        if self.normalize == "zero_one":
            img = img / 255.0  # [0,1]
        elif self.normalize == "neg_one_one":
            img = img / 255.0 * 2.0 - 1.0  # [-1,1]
        else:
            raise ValueError(f"Unknown normalize mode: {self.normalize}")

        # 轉 tensor，補上 channel 維度 -> (1,H,W)
        img_t = torch.from_numpy(img).unsqueeze(0)

        # 取得 letter id
        if self.format == "teacher":
            letter = sample["letter"]
        else:
            # generated 版本已保證有 letter 欄位
            letter = sample["letter"]
        letter_id = self.letter_to_id[letter]

        return img_t, letter_id
